From [here](https://0x434b.dev/overview-of-glibc-heap-exploitation-techniques/)

This goes over publically found GLIBC heap exploitation techniques
* divided into patched and unpached

# Basics
## Chunks
![[Pasted image 20240326162935.png]]
## Bins
Bins list structures of non-allocated chunks
* differentiated based on the size of the chunks they contain
### Fastbin
Fastbins are a collection of singly-linked non-circular lists
* each bin holds chunks of a fized size ranging from `0x20` to `0xb0`
* The head of the fastbin is stored in its arena
	* The 1st qword of the fastbin chunk's user data is repurposed as a forward pointer (`fd`) that points to the next chunk in a specific fastbin
		* a `fd` of `NULL` indicates the end of the list
* Fastbins are Last In First Out (LFIO) structures
* Chunks are directly linked to the corresponding fastbin if the tcache is present and the appropriately sized tcache bin is already full

When requesting a chunk within the fastbin size range, the search is prioritized as:
1) tcache bin
2) Fastbin
3) Unsortedbin
4) Top chunk
![[Pasted image 20240326163352.png]]
### Smallbins
Smallbins are **doubly linked** circular lists
* there are 62 in total
* each holds chunks of specific size
* The head of each smallbin is stored in the arena
* The list metadata (forward and backwards pointers) are stored inline in the freed chunks
![[Pasted image 20240326163545.png]]

## Unsorted Bins
A doubly linked circular list
* holds free chunks of any size

...skipped a few definitions that I feel like I already know

## Unlinking
Chunks might be unlinked from any of the free lists (bins) they were stored in during allocation/free operations.
* The unlinked chunk is often referred to as the "victim"
* Unlinking fastbins and tcache is pretty straightforward as they are singly linked LIFO lists
	* Process involves copying the victim's `fd` into the head of the list, which then points to the next free chunk following the victim
		* Effectively removes the *victim* from the list
* There is a *partial unlinking* process for bins allocated from the *small* and *unsorted* bins
	* The *victim*'s chunk `bk` is followed to the previous chunk
		* There, the address of the head of the bin is copied into the chunk's `fd`
	* Then the victim chunk's `bk` is copied over the `bk` of the head of the bin
* There is also a full unlink
	* Occurs when a chunk is consolidated into another free chunk or is allocated from the largebin
	* The victim's `fd` is followed
		* The victim `bk` is copied over the destination's `bk`
	* Then follow the victim's `bk`
		* Copy the victim's `fd` to the destination's `fd`
## Remaindering
This is the term for splitting a chunk into two parts
* One part is the requested size
* The other is the remainder
	* This part is linked into the unsorted bin

Remaindering can occur at three phases
1) During allocation from the largebins
2) During a binmap search
3) From a last remainder during unsortedbin scanning
## Exhausting
This is the term for when an `n` size chunk is requested, but only an `n + 0x10` sized chunk is found
	eg: in the unsorted bin
A remainder of `0x10` is an invalid chunk size
* malloc will just allocate the whole chunk as is instead of remaindering it
## Consolidation
The process of merging at least two free chunks on the heap into a larger free chunk
* done to avoid fragmentation
* Can also consolidate with the top chunk
# Malloc Hooks
These are very helpful during exploitation techniques
Unfortunately, they have been removed in `glibc > 2.34`
#### 1) `__malloc_hook`/ `__free_hook` / `__realloc_hook`
Located in a writable segment of glibc
If you can set the pointer (they default to 0)
* You can call whatever functionality the pointer points to when an allocation/free happens
	* This happens instead of the default GLIBC malloc/realloc/free functionality being called...
#### 2) `__after_morecore_hook`
The `__after_morecore_hook` variable points to a function that is called whenever `sbrk` is asked for more memory
#### 3) `__malloc_initialize_hook`
The `__malloc_initialize_hook`variable points to a function that is called once when the `malloc` implementation is initialized.
* Overwriting it with an attacker-controlled value would only be useful if `malloc` has not already been called
#### 4) `__memalign_hook`
When this is set, the function it points to will be called instead when one of the following functions is called:
*  `aligned_alloc()`
* `memalign()`
* `posix_memalign()`
* `valloc()` 
#### 5) `_dl_open_hook`
When a GLIBC abort message is triggered, typically `backtrace_and_maps()` is called to print the `stderr` trace
* When this happens:
	1) `__backtrace()` is called
	2) Within it, `init()` is called
	3) In `init()`, `__libc_dlopen()` and `__libc_dlsym()` are invoked
Essentially,
* If `_dl_open_hook` is **not** `NULL`
	* `_dl_open_hook`⇾`dlopen_mode` and `_dl_open_hook`⇾`dlsym` will be called
* Overwriting `dl_open_hook` with an attacker-controlled address will create a fake *vtable* at that address
# Patched Techiques
## House of Prime
**Overview**:
* Corrupt the *fastbin* maximum size variable
	* This holds the size of the largest allowable fastbin for `free` to create
* Under certain circumstances, this allows an attacker to hijack the arena structure, allowing either
	* A return to an arbitrary memory chunk