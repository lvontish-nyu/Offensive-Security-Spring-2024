From [CTF 101](https://ctf101.org/binary-exploitation/heap-exploitation/)
# Overflow
Much like a [[Stack Buffer Overflow]], a **heap overflow** is a vulnerability that occurs when a program reads in more data than can fit in the allocated buffer.
* Could lead to heap metadata corruption
* Could also corrupt other heap objects
	* Which will provide a new attack service
# Use After Free (UAF)
Once `free` is called on an allocation, the allocator is free to re-allocate that chunk of memory in future calls to `malloc`
* However, if the freed object is used later, the contents may be corrupted (or changed by an attacker)
* This is called a use-after-free (UAF)
### Example:
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

typedef struct string {
    unsigned length;
    char *data;
} string;

int main() {
    struct string* s = malloc(sizeof(string));
    puts("Length:");
    scanf("%u", &s->length);
    s->data = malloc(s->length + 1);
    memset(s->data, 0, s->length + 1);
    puts("Data:");
    read(0, s->data, s->length);
	
    free(s->data);
    free(s);
	
    char *s2 = malloc(16);
    memset(s2, 0, 16);
    puts("More data:");
    read(0, s2, 15);
	
    // Now using s again, a UAF
    puts(s->data);
	
    return 0;
}
```
###### We have a `string` structure with two pieces of data:
```c
typedef struct string {
    unsigned length;
    char *data;
} string;
```
1) The string length
2) A pointer to the string data
###### The program properly allocates, fills and frees an instance of this structure
```c
    struct string* s = malloc(sizeof(string));
    puts("Length:");
    scanf("%u", &s->length);
    s->data = malloc(s->length + 1);
    memset(s->data, 0, s->length + 1);
    puts("Data:");
    read(0, s->data, s->length);
	
    free(s->data);
    free(s);
```
###### Then it makes another allocation, fills it, and improperly references the freed string:
```c
	char *s2 = malloc(16);
    memset(s2, 0, 16);
    puts("More data:");
    read(0, s2, 15);
	
    // Now using s again, a UAF
    puts(s->data);
```

Because of how `glibc` allocates the data, `s2` will get the same memory as the original `s` allocation
* This gives us the ability to control the `s`->`data` pointer
	* Could use this to leak program data
# Advanced Heap Exploitation
Not only can the heap be exploited by the data in allocations, but exploits can also use the underlying mechanisms in `malloc`, `free`, ..etc, to exploit a program
## Recommended Resources:
https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/
https://github.com/shellphish/how2heap
[[Use After Free]]

